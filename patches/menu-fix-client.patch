diff -ur a/include/menu/menu.h b/include/menu/menu.h
--- a/include/menu/menu.h	2024-09-04 04:05:41.880247764 -0500
+++ b/include/menu/menu.h	2024-09-04 04:06:33.231559706 -0500
@@ -47,6 +47,7 @@
 	struct menu_scene normal;
 	struct menu_scene selected;
 	struct menu_pipe_context *pipe_ctx;
+	struct view *client_list_view;  /* used by internal client-list */
 	struct wl_list link; /* menu.menuitems */
 };
 
@@ -135,4 +136,7 @@
 /* menu_reconfigure - reload theme and content */
 void menu_reconfigure(struct server *server);
 
+void create_client_send_to_menu(struct server *server);
+void create_client_list_combined_menu(struct server *server);
+
 #endif /* LABWC_MENU_H */
diff -ur a/src/action.c b/src/action.c
--- a/src/action.c	2024-09-04 04:05:41.883247841 -0500
+++ b/src/action.c	2024-09-04 04:06:40.844754222 -0500
@@ -343,6 +343,14 @@
 			action_arg_add_bool(action, argument, parse_bool(content, true));
 			goto cleanup;
 		}
+		if (!strcasecmp(argument, "x")) {
+			action_arg_add_str(action, argument, content);
+			goto cleanup;
+		}
+		if (!strcasecmp(argument, "y")) {
+			action_arg_add_str(action, argument, content);
+			goto cleanup;
+		}
 		break;
 	case ACTION_TYPE_TOGGLE_MAXIMIZE:
 	case ACTION_TYPE_MAXIMIZE:
@@ -611,7 +619,8 @@
 
 static void
 show_menu(struct server *server, struct view *view,
-		const char *menu_name, bool at_cursor)
+		const char *menu_name, bool at_cursor,
+		const char *pos_x, const char *pos_y)
 {
 	if (server->input_mode != LAB_INPUT_STATE_PASSTHROUGH
 			&& server->input_mode != LAB_INPUT_STATE_MENU) {
@@ -624,6 +633,17 @@
 		return;
 	}
 
+	/*
+	 * need to be current for the running applications
+	 * as well as the width of the menu for placement
+	 * this is the only place it really works well.
+	 * --- Maybe Todo
+	 * If we redo menu_update_width then we could do things differently.
+	 * possibly carry max menu width as an int in struct menu
+	 */
+	create_client_list_combined_menu(menu->server);
+	create_client_send_to_menu(menu->server);
+
 	int x = server->seat.cursor->x;
 	int y = server->seat.cursor->y;
 
@@ -638,6 +658,52 @@
 		y = view->current.y;
 	}
 
+	/*
+	 * determine placement by looking at x and y
+	 * x/y can be number, "center" or a %percent of screen dimensions
+	 */
+	if (!at_cursor && pos_x && pos_y) {
+		struct output *output = output_nearest_to(server,
+				server->seat.cursor->x, server->seat.cursor->y);
+		struct wlr_box output_box;
+		struct menuitem *item;
+		struct theme *theme = server->theme;
+		int max_width = theme->menu_min_width;
+
+		wl_list_for_each(item, &menu->menuitems, link) {
+			if (item->native_width > max_width) {
+				max_width = item->native_width < theme->menu_max_width
+					? item->native_width : theme->menu_max_width;
+			}
+		}
+
+		wlr_output_layout_get_box(server->output_layout, output->wlr_output, &output_box);
+
+		if (!strcasecmp(pos_x, "center")) {
+			x = (output->usable_area.width / 2) - (max_width / 2);
+		} else if (strchr(pos_x, '%')) {
+			x = (output->usable_area.width * atoi(pos_x)) / 100;
+		} else {
+			x = atoi(pos_x);
+		}
+
+		if (!strcasecmp(pos_y, "center")) {
+			y = (output->usable_area.height / 2) - (menu->size.height / 2);
+		} else if (strchr(pos_y, '%')) {
+			y = (output->usable_area.height * atoi(pos_y)) / 100;
+		} else {
+			y = atoi(pos_y);
+		}
+		/* keep menu from being off screen */
+		x = MAX(x, 0);
+		x = MIN(x, output->usable_area.width);
+		y = MAX(y, 0);
+		y = MIN(y, output->usable_area.height);
+		/* adjust for which monitor to appear on */
+		x += output_box.x;
+		y += output_box.y;
+	}
+
 	/* Replaced by next show_menu() or cleaned on view_destroy() */
 	menu->triggered_by_view = view;
 	menu_open_root(menu, x, y);
@@ -843,7 +909,9 @@
 		case ACTION_TYPE_SHOW_MENU:
 			show_menu(server, view,
 				action_get_str(action, "menu", NULL),
-				action_get_bool(action, "atCursor", true));
+				action_get_bool(action, "atCursor", true),
+				action_get_str(action, "x", NULL),
+				action_get_str(action, "y", NULL));
 			break;
 		case ACTION_TYPE_TOGGLE_MAXIMIZE:
 			if (view) {
diff -ur a/src/menu/menu.c b/src/menu/menu.c
--- a/src/menu/menu.c	2024-09-04 04:05:41.885247892 -0500
+++ b/src/menu/menu.c	2024-09-04 04:06:33.231559706 -0500
@@ -23,6 +23,8 @@
 #include "common/string-helpers.h"
 #include "labwc.h"
 #include "menu/menu.h"
+#include "workspaces.h"
+#include "view.h"
 #include "node.h"
 #include "theme.h"
 
@@ -581,27 +583,32 @@
 
 	if (execute && label && id) {
 		wlr_log(WLR_DEBUG, "pipemenu '%s:%s:%s'", id, label, execute);
-		if (!current_menu) {
+		if (!current_menu || !current_menu->parent) {
 			/*
-			 * We currently do not support pipemenus without a
-			 * parent <item> such as the one the example below:
+			 * pipemenus without a parent
 			 *
 			 * <?xml version="1.0" encoding="UTF-8"?>
 			 * <openbox_menu>
 			 *   <menu id="root-menu" label="foo" execute="bar"/>
 			 * </openbox_menu>
-			 *
-			 * TODO: Consider supporting this
 			 */
-			wlr_log(WLR_ERROR,
-				"pipemenu '%s:%s:%s' has no parent <menu>",
-				id, label, execute);
-			goto error;
+			current_menu = menu_create(server, id, label);
+			current_menu->is_pipemenu = true;
+			current_item = item_create(current_menu, label,
+					/* arrow */ true);
+			current_item_action = NULL;
+			current_item->execute = xstrdup(execute);
+			current_item->id = xstrdup(id);
+		} else {
+			/*
+			 * pipemenus with a parent
+			 */
+			current_item = item_create(current_menu, label,
+					/* arrow */ true);
+			current_item_action = NULL;
+			current_item->execute = xstrdup(execute);
+			current_item->id = xstrdup(id);
 		}
-		current_item = item_create(current_menu, label, /* arrow */ true);
-		current_item_action = NULL;
-		current_item->execute = xstrdup(execute);
-		current_item->id = xstrdup(id);
 	} else if ((label && id) || is_toplevel_static_menu_definition(n, id)) {
 		/*
 		 * (label && id) refers to <menu id="" label=""> which is an
@@ -634,6 +641,7 @@
 		}
 		++menu_level;
 		current_menu = menu_create(server, id, label);
+		current_menu->is_pipemenu = false;
 		if (submenu) {
 			*submenu = current_menu;
 		}
@@ -657,8 +665,23 @@
 		}
 
 		struct menu *menu = menu_get_by_id(server, id);
-		if (menu) {
+		if (menu && menu->is_pipemenu) {
+			/*
+			 * A pipemenu without a parent
+			 */
 			current_item = item_create(current_menu, menu->label, true);
+			struct menuitem *item;
+			wl_list_for_each(item, &menu->menuitems, link) {
+				current_item->execute = xstrdup(item->execute);
+				current_item->id = strdup_printf("%s%d",
+						item->id, rand());
+			}
+		} else if (menu) {
+			/*
+			 * An inline menu defined elsewhere
+			 */
+			current_item = item_create(current_menu, menu->label,
+					true);
 			if (current_item) {
 				current_item->submenu = menu;
 			}
@@ -908,6 +931,118 @@
 	}
 }
 
+/*
+ * This is client-send-to-menu
+ * an internal menu similar to root-menu and client-menu
+ *
+ * This will look at workspaces and produce a menu
+ * with the workspace names that can be used with
+ * SendToDesktop, left/right options are included.
+ */
+void
+create_client_send_to_menu(struct server *server)
+{
+	struct menu *menu = menu_get_by_id(server,
+			"client-send-to-menu");
+
+	if (menu) {
+		struct menuitem *item, *next;
+		wl_list_for_each_safe(item, next, &menu->menuitems, link) {
+			item_destroy(item);
+		}
+	} else {
+		menu = menu_create(server, "client-send-to-menu", "Send to...");
+	}
+
+	menu->size.height = 0;
+
+	struct workspace *workspace;
+
+	wl_list_init(&menu->menuitems);
+	wl_list_for_each(workspace, &server->workspaces, link) {
+		if (workspace == server->workspace_current) {
+			current_item = item_create(menu, strdup_printf(">%s<", workspace->name),
+					/*show arrow*/ false);
+		} else {
+			current_item = item_create(menu, workspace->name, /*show arrow*/ false);
+		}
+		fill_item("name.action", "SendToDesktop");
+		fill_item("to.action", workspace->name);
+	}
+
+	current_item = separator_create(menu, "");
+	current_item = item_create(menu, "left", /*show arrow*/ false);
+	fill_item("name.action", "SendToDesktop");
+	fill_item("to.action", "left");
+	current_item = item_create(menu, "right", /*show arrow*/ false);
+	fill_item("name.action", "SendToDesktop");
+	fill_item("to.action", "right");
+	menu_update_width(menu);
+	wlr_scene_node_set_enabled(&menu->scene_tree->node, false);
+}
+
+/*
+ * This is client-list-combined-menu
+ * an internal menu similar to root-menu and client-menu
+ *
+ * This will look at workspaces and produce a menu
+ * with the workspace name as a separator label
+ * and the titles of the view, if any, below each workspace name.
+ * Active view is indicated by "*" preceeding title.
+ */
+void
+create_client_list_combined_menu(struct server *server)
+{
+	struct menu *menu = menu_get_by_id(server,
+			"client-list-combined-menu");
+
+	if (menu) {
+		struct menuitem *item, *next;
+		wl_list_for_each_safe(item, next, &menu->menuitems, link) {
+			item_destroy(item);
+		}
+	} else {
+		menu = menu_create(server, "client-list-combined-menu", "Clients...");
+	}
+
+	menu->size.height = 0;
+
+	struct workspace *workspace;
+	struct view *view;
+	struct buf buffer = BUF_INIT;
+
+	wl_list_init(&menu->menuitems);
+	wl_list_for_each(workspace, &server->workspaces, link) {
+		buf_add_fmt(&buffer, workspace == server->workspace_current ? ">%s<" : "%s",
+				workspace->name);
+		current_item = separator_create(menu, buffer.data);
+		buf_clear(&buffer);
+
+		wl_list_for_each(view, &server->views, link) {
+			if (view->workspace == workspace) {
+				if (view == server->active_view) {
+					buf_add(&buffer, "*");
+				}
+				buf_add(&buffer, view_get_string_prop(view, "title"));
+
+				current_item = item_create(menu, buffer.data, /*show arrow*/ false);
+				current_item->id = xstrdup(menu->id);
+				current_item->client_list_view = view;
+				fill_item("name.action", "Focus");
+				fill_item("name.action", "Raise");
+				buf_clear(&buffer);
+			}
+		}
+		current_item = item_create(menu, "Go there...", /*show arrow*/ false);
+		current_item->id = xstrdup(menu->id);
+		fill_item("name.action", "GoToDesktop");
+		fill_item("to.action", workspace->name);
+	}
+	buf_reset(&buffer);
+	menu_update_width(menu);
+	wlr_scene_node_set_enabled(&menu->scene_tree->node, false);
+}
+
 static void
 init_rootmenu(struct server *server)
 {
@@ -983,6 +1118,8 @@
 menu_init(struct server *server)
 {
 	wl_list_init(&server->menus);
+	create_client_list_combined_menu(server);
+	create_client_send_to_menu(server);
 	parse_xml("menu.xml", server);
 	init_rootmenu(server);
 	init_windowmenu(server);
@@ -1467,7 +1604,13 @@
 	 * menu_close() and destroy_pipemenus() which we have to handle
 	 * before/after action_run() respectively.
 	 */
-	actions_run(item->parent->triggered_by_view, server, &item->actions, 0);
+	if (item->id && !strcmp(item->id, "client-list-combined-menu")
+			&& item->client_list_view) {
+		actions_run(item->client_list_view, server, &item->actions, 0);
+	} else {
+		actions_run(item->parent->triggered_by_view, server,
+				&item->actions, 0);
+	}
 
 	server->menu_current = NULL;
 	destroy_pipemenus(server);
